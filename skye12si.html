<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>S.P.A.D.E.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body { margin:0; font-family: Arial, sans-serif; }
    #wrap { display:grid; grid-template-columns: 560px 1fr; height:100vh; }
    #sidebar { padding:12px; border-right:1px solid #ddd; overflow:auto; background:#fff; }
    #map { height:100vh; }

    h2 { margin: 8px 0 6px; }
    .small { color:#666; font-size:12px; }
    .pill { display:inline-block; padding:6px 10px; border:1px solid #ddd; border-radius:999px; margin-top:6px; background:#fafafa; }
    .row { margin:12px 0; }
    label { display:block; font-weight:700; margin:0 0 6px; }

    input, select, button {
      width:100%;
      padding:8px;
      box-sizing:border-box;
      border-radius:10px;
      border:1px solid #ccc;
      font-size:14px;
    }
    button { cursor:pointer; background:#111; color:#fff; border-color:#111; }
    button.secondary { background:#fff; color:#111; border-color:#ccc; }
    button.smallBtn { width:auto; padding:6px 10px; font-size:12px; border-radius:10px; }

    .twoCol { display:flex; gap:8px; align-items:center; }
    .twoCol input { flex:1; }
    .twoCol button { width:auto; }

    .filtersHeader { display:flex; align-items:flex-end; justify-content:space-between; gap:10px; }
    .filtersHeader .left { flex:1; }
    .filtersHeader .right { display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .filtersHeader .right button { width:auto; }

    #filtersGrid {
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .filterBox {
      border:1px solid #eee;
      border-radius:12px;
      padding:10px;
      background:#fff;
    }
    .filterLabel { font-weight:700; font-size:12px; margin-bottom:6px; }
    .filterHint { font-size:11px; color:#777; margin-top:6px; }
    .hidden { display:none !important; }

    .plant { border:1px solid #eee; border-radius:12px; padding:10px; margin:10px 0; background:#fff; }
    .plant b { display:block; margin-bottom:3px; font-size:16px; }
    .kv { margin-top:8px; }
    .kv div { font-size:12px; color:#333; margin:2px 0; }
    .kv span.key { color:#666; }
    code { background:#f6f6f6; padding:2px 4px; border-radius:6px; }

    .moreRow{
      display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:10px;
    }
    .moreRow button{ width:auto; }

    .detailsBox{
      margin-top:10px;
      padding-top:10px;
      border-top:1px dashed #e5e5e5;
    }
    .detailsBoxSummary{
      font-weight:700; font-size:12px; margin-bottom:8px;
    }
    .detailsGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:6px;
      margin-top:8px;
    }
    .detailLine{
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      border:1px solid #f0f0f0;
      background:#fafafa;
      border-radius:10px;
      padding:8px;
      font-size:12px;
    }
    .detailKey{
      color:#555;
      font-weight:700;
      min-width: 160px;
      max-width: 200px;
      flex: 0 0 auto;
    }
    .detailVal{
      color:#222;
      flex: 1 1 auto;
      text-align:left;
      white-space:pre-wrap;
      word-break:break-word;
    }

    .pagerBottom{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:wrap;
      margin:12px 0 6px;
    }
    .pagerBottom button{ width:auto; }
    .pagerBottom .meta{ font-size:12px; color:#666; }

    .quickBox { border:1px solid #eee; border-radius:12px; padding:10px; background:#fff; }
    .quickList { margin-top:8px; }
    .quickItem {
      border:1px solid #f0f0f0; border-radius:10px; padding:8px; background:#fafafa;
      cursor:pointer; margin:6px 0;
    }
    .quickItem:hover { border-color:#ddd; background:#f7f7f7; }

    /* Debug */
    #debugFab { position:fixed; right:14px; bottom:14px; z-index:9999; padding:10px 12px; border-radius:999px; border:1px solid #333; background:#111; color:#fff; cursor:pointer; font-size:14px; width:auto; }
    #debugModalBackdrop { position:fixed; inset:0; background:rgba(0,0,0,0.55); z-index:9998; display:none; }
    #debugModal { position:fixed; right:14px; bottom:62px; width:min(780px, calc(100vw - 28px)); height:min(540px, calc(100vh - 90px)); background:#fff; border:1px solid #ddd; border-radius:14px; z-index:9999; display:none; overflow:hidden; box-shadow:0 8px 30px rgba(0,0,0,0.25); }
    #debugModalHeader { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #eee; background:#f7f7f7; }
    #debugModalHeader .btnRow { display:flex; gap:8px; }
    .debugBtn { width:auto; padding:6px 10px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer; font-size:12px; color:#111; }
    #debugLogArea { height:calc(100% - 46px); padding:10px 12px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; white-space:pre-wrap; background:#fff; }

    /* Header sizing (smaller title + subtitles) */
    .appTitle { font-size:22px; font-weight:800; margin:6px 0 2px; letter-spacing:0.5px; }
    .appSubtitle { font-size:13px; font-weight:700; margin:0; color:#111; }
    .appByline { font-size:12px; margin:2px 0 10px; color:#555; }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="sidebar">

      <!-- UPDATED HEADER -->
      <div class="appTitle">S.P.A.D.E.</div>
      <div class="appSubtitle">Site Preservation and Dirt Erosion-Control</div>
      <div class="appByline">Made by Blazing Turtles Robotics</div>

      <div class="small">
        Browse plants right away (no ecoregion required). Hover regions for tooltip details; click a region to highlight it and dim others.
      </div>

      <div class="row">
        <label>Selected Ecoregion (optional)</label>
        <div id="selectedRegion" class="pill">All regions</div>
        <div class="small" style="margin-top:6px;">
          Pick a region from the dropdown, click the map, use ZIP, enter lat/lng, or ‚ÄúUse my location‚Äù.
        </div>
      </div>

      <div class="row">
        <label>Quick plant lookup (no ecoregion needed)</label>
        <div class="quickBox">
          <input id="plantLookup" placeholder="Search a plant name (common or scientific)..." />
          <div class="small" style="margin-top:6px;">Click a result to open it in the list below with ‚ÄúMore info‚Äù.</div>
          <div id="quickList" class="quickList"></div>
        </div>
      </div>

      <div class="row">
        <label>Find my ecoregion</label>

        <div class="small" style="margin-bottom:6px;">
          Option A ‚Äî ZIP code
        </div>
        <div class="twoCol">
          <input id="zipInput" placeholder="Enter ZIP (US)" inputmode="numeric" />
          <button id="zipFindBtn" class="secondary smallBtn" type="button">Find</button>
          <button id="zipLocBtn" class="secondary smallBtn" type="button">Use my location (ZIP)</button>
        </div>

        <div class="small" style="margin-top:10px; margin-bottom:6px;">
          Option B ‚Äî Latitude / Longitude
        </div>
        <div class="twoCol">
          <input id="latInput" placeholder="Latitude (e.g., 41.8781)" inputmode="decimal" />
          <input id="lngInput" placeholder="Longitude (e.g., -87.6298)" inputmode="decimal" />
          <button id="latlngFindBtn" class="secondary smallBtn" type="button">Go</button>
          <button id="latlngLocBtn" class="secondary smallBtn" type="button">Use my location (Lat/Lng)</button>
        </div>

        <div class="small" id="geoStatus" style="margin-top:8px;">
          ZIP/lat-lng/location will auto-select an ecoregion and zoom.
        </div>
      </div>

      <div class="row">
        <label>Search results list (Common or Scientific name)</label>
        <input id="searchBox" placeholder="type to filter‚Ä¶" />
      </div>

      <div class="row">
        <div class="filtersHeader">
          <div class="left">
            <label style="margin:0;">Filters (separate per category)</label>
            <div class="small">Vendor + link columns removed. ‚ÄúAdvanced‚Äù hides very large dropdowns.</div>
          </div>
          <div class="right">
            <button id="clearFiltersBtn" class="secondary smallBtn" type="button">Clear filters</button>
            <button id="toggleAdvancedBtn" class="secondary smallBtn" type="button">Show advanced</button>
          </div>
        </div>

        <div id="filtersGrid"></div>
      </div>

      <div class="row">
        <label style="margin:0;">Results <span class="small" id="resultCount"></span></label>
        <div class="small" id="activeFiltersLine"></div>

        <div id="results"></div>

        <div class="pagerBottom">
          <button id="prevBtn" class="secondary smallBtn" type="button">Prev</button>
          <button id="nextBtn" class="secondary smallBtn" type="button">Next</button>
          <div class="meta" id="pageMeta"></div>
        </div>
      </div>

      <hr/>
      <div class="small" id="status">Loading‚Ä¶</div>
      <div class="small" id="colInfo"></div>
    </div>

    <div id="map"></div>
  </div>

  <button id="debugFab">Debug</button>
  <div id="debugModalBackdrop"></div>
  <div id="debugModal">
    <div id="debugModalHeader">
      <b>Debug Log</b>
      <div class="btnRow">
        <button class="debugBtn" id="debugCopyBtn">Copy</button>
        <button class="debugBtn" id="debugClearBtn">Clear</button>
        <button class="debugBtn" id="debugCloseBtn">Close</button>
      </div>
    </div>
    <div id="debugLogArea">(No logs yet)</div>
  </div>

<script>
  // ============================================================
  // FILES IN /assets/
  // ============================================================
  const ECOREGIONS_URL = '/assets/us_eco_l3_state_boundaries.json';
  const DATABASE_CSV_URL = '/assets/Database-Deleted-Categories.csv';

  // ============================================================
  // REMOVE THESE COMPLETELY
  // ============================================================
  const EXCLUDED_COLUMNS = new Set([
    'Vendor', 'POTENTIAL_VENDOR',
    'VENDOR_LINK_TO_ORDER', 'ALTERNATIVE_LINK_TO_ORDER',
    'SOURCE_LINK_1', 'SOURCE_LINK_2', 'SOURCE_LINK_3', 'SOURCE_LINK_4'
  ]);

  // Pagination
  const PAGE_SIZE = 20;
  let currentPage = 1;

  // Debug
  const DEBUG_LOG_MAX_LINES = 350;
  let debugLines = [];
  function logDebug(message, data){
    const ts = new Date().toISOString().replace('T',' ').replace('Z','');
    let line = `[${ts}] ${message}`;
    if (data !== undefined) { try { line += ` | ${typeof data === 'string' ? data : JSON.stringify(data)}`; } catch { line += ` | (unstringifiable)`; } }
    debugLines.push(line);
    if (debugLines.length > DEBUG_LOG_MAX_LINES) debugLines = debugLines.slice(-DEBUG_LOG_MAX_LINES);
    const area = document.getElementById('debugLogArea');
    if (area) area.textContent = debugLines.length ? debugLines.join('\n') : '(No logs yet)';
  }
  function openDebug(){ document.getElementById('debugModalBackdrop').style.display='block'; document.getElementById('debugModal').style.display='block'; }
  function closeDebug(){ document.getElementById('debugModalBackdrop').style.display='none'; document.getElementById('debugModal').style.display='none'; }

  function setStatus(msg){ document.getElementById('status').textContent = msg; logDebug('‚ÑπÔ∏è status', msg); }
  function setGeoStatus(msg){ const el = document.getElementById('geoStatus'); if (el) el.textContent = msg; logDebug('üìç geo', msg); }

  function normalizeKey(s){ return String(s ?? '').toLowerCase().replace(/[\s_\-]+/g,''); }
  function normText(s){ return String(s ?? '').toLowerCase().trim(); }
  function escapeHtml(s){ return String(s ?? '').replace(/[&<>"]/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[ch])); }

  function extractLeadingCode(text){
    const s = String(text ?? '').trim();
    const m = s.match(/^(\d{1,3})\b/);
    return m ? m[1] : '';
  }
  function tokenizeCell(cell){
    const s = String(cell ?? '').trim();
    if (!s) return [];
    const parts = s.split(/[,;|\/]+/g).map(x => x.trim()).filter(Boolean);
    return parts.length ? parts : [s];
  }
  function isYesNoLike(v){
    const s = normText(v);
    return s === 'yes' || s === 'no' || s === 'yes [uncertain]' || s === 'no [uncertain]' || s === 'true' || s === 'false' || s === '1' || s === '0';
  }
  function canonicalYesNoOptions(valuesSet){
    const present = new Set([...valuesSet].map(v => String(v).trim()));
    const base = ['Yes','No'];
    const extra = [];
    if (present.has('Yes [UNCERTAIN]')) extra.push('Yes [UNCERTAIN]');
    if (present.has('No [UNCERTAIN]')) extra.push('No [UNCERTAIN]');
    if (present.has('True')) extra.push('True');
    if (present.has('False')) extra.push('False');
    if (present.has('1')) extra.push('1');
    if (present.has('0')) extra.push('0');
    return [...base, ...extra];
  }
  function matchesDropdownCell(cell, want){
    const w = String(want ?? '').trim();
    if (!w) return true;
    const cellStr = String(cell ?? '').trim();
    if (!cellStr) return false;

    const tokens = tokenizeCell(cellStr);
    const wn = normText(w);
    if (tokens.length >= 2) return tokens.some(t => normText(t) === wn);
    return normText(cellStr).includes(wn);
  }

  // ============================================================
  // FAST CSV PARSER (no PapaParse needed)
  // Handles quotes, commas, CRLF.
  // ============================================================
  function parseCSV(text){
    const rows = [];
    const headers = [];

    let i = 0;
    const len = text.length;
    let field = '';
    let row = [];
    let inQuotes = false;

    function pushField(){
      row.push(field);
      field = '';
    }
    function pushRow(){
      const allEmpty = row.length === 1 && String(row[0] ?? '').trim() === '';
      if (!allEmpty) rows.push(row);
      row = [];
    }

    while (i < len) {
      const ch = text[i];

      if (inQuotes) {
        if (ch === '"') {
          const next = text[i+1];
          if (next === '"') { field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        } else {
          field += ch; i++; continue;
        }
      } else {
        if (ch === '"') { inQuotes = true; i++; continue; }
        if (ch === ',') { pushField(); i++; continue; }
        if (ch === '\r') {
          pushField(); pushRow();
          if (text[i+1] === '\n') i += 2; else i += 1;
          continue;
        }
        if (ch === '\n') { pushField(); pushRow(); i++; continue; }
        field += ch; i++; continue;
      }
    }
    pushField();
    if (row.length) pushRow();

    if (!rows.length) return { headers: [], rows: [] };

    const hdr = rows.shift().map(h => String(h ?? '').trim());
    hdr.forEach(h => headers.push(h));

    const out = [];
    for (const r of rows) {
      if (!r || !r.length) continue;
      const obj = {};
      for (let c = 0; c < headers.length; c++) obj[headers[c]] = r[c] ?? '';
      out.push(obj);
    }
    return { headers, rows: out };
  }

  // ============================================================
  // Map
  // ============================================================
  const map = L.map('map', { worldCopyJump:true }).setView([39.5, -98.35], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:18, attribution:'&copy; OpenStreetMap contributors' }).addTo(map);

  let ecoregionsLayer = null;
  let selectedProps = null; // null = all regions
  let ecoregionGeoJSON = null;
  let userMarker = null;

  // ============================================================
  // CSV state
  // ============================================================
  let csvHeaders = [];
  let plants = []; // all plants

  const L3_KEY_CANDIDATES = ['L3_KEY', 'L3 KEY', 'L3Key', 'L3_key'];
  const COMMON_CANDIDATES = ['Common Name', 'COMMON_NAME', 'Common'];
  const SCI_CANDIDATES = ['Scientific Name', 'SCIENTIFIC_NAME', 'Scientific'];

  let colL3Key = 'L3_KEY';
  let colCommon = 'Common Name';
  let colScientific = 'Scientific Name';

  let plantsByL3Raw = new Map();
  let plantsByL3Norm = new Map();
  let plantsByCode = new Map();

  let regionFilterControl = null;
  let regionIndex = [];
  let regionKeyToProps = new Map();

  let detailColumns = [];

  function addTo(mapObj, key, item){
    if (!key) return;
    if (!mapObj.has(key)) mapObj.set(key, []);
    mapObj.get(key).push(item);
  }
  function indexPlants(){
    plantsByL3Raw = new Map();
    plantsByL3Norm = new Map();
    plantsByCode = new Map();
    for (const p of plants) {
      addTo(plantsByL3Raw, p.l3Raw, p);
      addTo(plantsByL3Norm, p.l3Norm, p);
      if (p.l3Code) addTo(plantsByCode, p.l3Code, p);
    }
    logDebug('‚úÖ indexed plants', { rawKeys: plantsByL3Raw.size, normKeys: plantsByL3Norm.size, codes: plantsByCode.size });
  }

  function getPlantsForRegionProps(props){
    if (!props) return plants;
    const rawKey = String(props.L3_KEY ?? '').trim();
    const normKey = normalizeKey(rawKey);
    const code = String(props.US_L3CODE ?? '').trim() || extractLeadingCode(rawKey);

    if (rawKey && plantsByL3Raw.has(rawKey)) return plantsByL3Raw.get(rawKey);
    if (normKey && plantsByL3Norm.has(normKey)) return plantsByL3Norm.get(normKey);
    if (code && plantsByCode.has(code)) return plantsByCode.get(code);
    return [];
  }

  function getCountForRegion(props){
    if (!props) return plants.length;
    return getPlantsForRegionProps(props).length;
  }

  function buildTooltipHtml(props){
    const rawKey = String(props?.L3_KEY ?? '').trim();
    const code = String(props?.US_L3CODE ?? '').trim() || extractLeadingCode(rawKey);
    const name = props?.US_L3NAME || props?.NA_L3NAME || '';
    const count = getCountForRegion(props);
    return `
      <div style="font-size:12px; line-height:1.25;">
        <div><b>${escapeHtml(code || rawKey || 'Unknown')}</b>${name ? ` ‚Äî ${escapeHtml(name)}` : ''}</div>
        <div style="color:#555;">Plants in CSV: <b>${count.toLocaleString()}</b></div>
      </div>
    `;
  }

  function styleForFeature(){ return { color:'#555', weight:1, opacity:0.8, fillColor:'#4f46e5', fillOpacity:0.15 }; }
  function styleForDimmed(){ return { color:'#777', weight:1, opacity:0.25, fillColor:'#999', fillOpacity:0.05 }; }
  function styleForSelected(){ return { color:'#111', weight:3, opacity:1, fillColor:'#f59e0b', fillOpacity:0.45 }; }

  function applySelectionStyles(){
    if (!ecoregionsLayer) return;
    ecoregionsLayer.eachLayer((layer)=>{
      const p = layer?.feature?.properties || {};
      if (!selectedProps) { layer.setStyle(styleForFeature()); return; }
      const key = String(p.L3_KEY ?? '').trim();
      const selKey = String(selectedProps.L3_KEY ?? '').trim();
      if (key && selKey && key === selKey) { layer.setStyle(styleForSelected()); try { layer.bringToFront(); } catch {} }
      else layer.setStyle(styleForDimmed());
    });
  }
  function refreshAllTooltips(){
    if (!ecoregionsLayer) return;
    ecoregionsLayer.eachLayer((layer)=>{
      const p = layer?.feature?.properties || {};
      const tt = layer.getTooltip ? layer.getTooltip() : null;
      if (tt && tt.setContent) tt.setContent(buildTooltipHtml(p));
    });
  }

  // Point-in-polygon for finding ecoregion from coordinates
  function showUserMarker(lat, lng) {
    try { if (userMarker) map.removeLayer(userMarker); } catch {}
    userMarker = L.circleMarker([lat, lng], { radius:7, weight:2, opacity:1, fillOpacity:0.6 }).addTo(map);
  }

  function pointInRing(pointLngLat, ringLngLat) {
    const x = pointLngLat[0], y = pointLngLat[1];
    let inside = false;
    for (let i=0, j=ringLngLat.length-1; i<ringLngLat.length; j=i++) {
      const xi = ringLngLat[i][0], yi = ringLngLat[i][1];
      const xj = ringLngLat[j][0], yj = ringLngLat[j][1];
      const intersect = ((yi>y)!==(yj>y)) && (x < ((xj-xi)*(y-yi))/(yj-yi+0.0)+xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function pointInPolygon(pointLngLat, polygonCoords) {
    if (!polygonCoords || !polygonCoords.length) return false;
    const outer = polygonCoords[0];
    if (!pointInRing(pointLngLat, outer)) return false;
    for (let h=1; h<polygonCoords.length; h++) {
      if (pointInRing(pointLngLat, polygonCoords[h])) return false;
    }
    return true;
  }
  function pointInGeometry(pointLngLat, geometry) {
    if (!geometry) return false;
    if (geometry.type === 'Polygon') return pointInPolygon(pointLngLat, geometry.coordinates);
    if (geometry.type === 'MultiPolygon') {
      for (const poly of geometry.coordinates) if (pointInPolygon(pointLngLat, poly)) return true;
      return false;
    }
    return false;
  }
  function findEcoregionForLatLng(lat, lng) {
    if (!ecoregionGeoJSON?.features?.length) return null;
    const pt = [lng, lat];
    for (const f of ecoregionGeoJSON.features) {
      if (pointInGeometry(pt, f.geometry)) return f.properties || null;
    }
    return null;
  }

  function selectRegionProps(props, opts = {}) {
    selectedProps = props || null;

    if (!selectedProps) {
      document.getElementById('selectedRegion').textContent = 'All regions';
      if (regionFilterControl) regionFilterControl.el.value = '';
    } else {
      const rawKey = String(selectedProps.L3_KEY ?? '').trim();
      const code = String(selectedProps.US_L3CODE ?? '').trim() || extractLeadingCode(rawKey);
      const name = selectedProps.US_L3NAME || selectedProps.NA_L3NAME || '';
      document.getElementById('selectedRegion').textContent = `${code || rawKey}${name ? ' ‚Äî ' + name : ''}`;
      if (regionFilterControl) regionFilterControl.el.value = rawKey;
    }

    applySelectionStyles();

    const base = getPlantsForRegionProps(selectedProps);
    rebuildDropdownOptionsFromList(base);

    currentPage = 1;
    renderResults();

    if (opts.panTo && opts.lat != null && opts.lng != null) {
      map.setView([opts.lat, opts.lng], opts.zoom || 8);
    }
  }

  // ZIP / LatLng / Geolocation
  async function findByZip(zip) {
    const z = String(zip || '').trim();
    if (!/^\d{5}(-\d{4})?$/.test(z)) { setGeoStatus('Please enter a valid US ZIP (5 digits).'); return; }
    setGeoStatus('Looking up ZIP‚Ä¶');

    try {
      const res = await fetch(`https://api.zippopotam.us/us/${encodeURIComponent(z)}`, { cache: 'no-store' });
      if (!res.ok) throw new Error(`ZIP lookup failed (${res.status})`);
      const data = await res.json();
      const place = data?.places?.[0];
      const lat = place ? parseFloat(place.latitude) : null;
      const lng = place ? parseFloat(place.longitude) : null;
      if (lat == null || lng == null || Number.isNaN(lat) || Number.isNaN(lng)) throw new Error('ZIP lookup returned no coordinates.');

      showUserMarker(lat, lng);
      const props = findEcoregionForLatLng(lat, lng);
      if (!props) { setGeoStatus(`ZIP ${z} found (${lat.toFixed(4)}, ${lng.toFixed(4)}), but no ecoregion polygon matched.`); map.setView([lat, lng], 8); return; }

      selectRegionProps(props, { panTo:true, lat, lng, zoom:8 });
      setGeoStatus(`Selected ecoregion for ZIP ${z}.`);
    } catch (err) {
      setGeoStatus(`ZIP lookup error: ${err.message}`);
      logDebug('‚ùå ZIP lookup error', String(err));
    }
  }

  function parseNumberLoose(s) {
    const t = String(s ?? '').trim().replace(/[^\d\.\-+eE]/g, '');
    if (!t) return null;
    const n = Number(t);
    return Number.isFinite(n) ? n : null;
  }

  function findByLatLngInputs() {
    const lat = parseNumberLoose(document.getElementById('latInput')?.value);
    const lng = parseNumberLoose(document.getElementById('lngInput')?.value);

    if (lat == null || lng == null) { setGeoStatus('Please enter both latitude and longitude (numbers).'); return; }
    if (lat < -90 || lat > 90) { setGeoStatus('Latitude must be between -90 and 90.'); return; }
    if (lng < -180 || lng > 180) { setGeoStatus('Longitude must be between -180 and 180.'); return; }

    showUserMarker(lat, lng);
    const props = findEcoregionForLatLng(lat, lng);
    if (!props) { setGeoStatus(`Coordinates (${lat.toFixed(4)}, ${lng.toFixed(4)}) did not match any ecoregion polygon.`); map.setView([lat, lng], 8); return; }

    selectRegionProps(props, { panTo:true, lat, lng, zoom:8 });
    setGeoStatus(`Selected ecoregion for coordinates (${lat.toFixed(4)}, ${lng.toFixed(4)}).`);
  }

  function useMyLocationLatLng() {
    if (!navigator.geolocation) { setGeoStatus('Geolocation is not supported in this browser.'); return; }
    setGeoStatus('Requesting location permission‚Ä¶');
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        document.getElementById('latInput').value = lat.toFixed(6);
        document.getElementById('lngInput').value = lng.toFixed(6);
        showUserMarker(lat, lng);

        const props = findEcoregionForLatLng(lat, lng);
        if (!props) { setGeoStatus(`Location found (${lat.toFixed(4)}, ${lng.toFixed(4)}), but no ecoregion polygon matched.`); map.setView([lat, lng], 8); return; }

        selectRegionProps(props, { panTo:true, lat, lng, zoom:8 });
        setGeoStatus('Selected ecoregion for your location (Lat/Lng).');
      },
      (err) => setGeoStatus(`Location error: ${err.message}`),
      { enableHighAccuracy:true, timeout:10000, maximumAge:60000 }
    );
  }

  async function useMyLocationZip() {
    if (!navigator.geolocation) { setGeoStatus('Geolocation is not supported in this browser.'); return; }
    setGeoStatus('Requesting location permission‚Ä¶');
    navigator.geolocation.getCurrentPosition(
      async (pos) => {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        showUserMarker(lat, lng);
        map.setView([lat, lng], 8);

        try {
          setGeoStatus('Finding ZIP from your location‚Ä¶');
          const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}`;
          const res = await fetch(url, { cache:'no-store', headers: { 'Accept': 'application/json' } });
          if (!res.ok) throw new Error(`Reverse geocode failed (${res.status})`);
          const data = await res.json();
          const zip = data?.address?.postcode ? String(data.address.postcode).trim() : '';
          if (!zip) throw new Error('No ZIP found from reverse geocode.');

          document.getElementById('zipInput').value = zip;
          await findByZip(zip);
          setGeoStatus(`Selected ecoregion for your location (ZIP ${zip}).`);
        } catch (e) {
          logDebug('‚ö†Ô∏è ZIP reverse geocode failed, fallback to Lat/Lng', String(e));
          const props = findEcoregionForLatLng(lat, lng);
          if (!props) { setGeoStatus(`Location found (${lat.toFixed(4)}, ${lng.toFixed(4)}), but no ecoregion polygon matched.`); return; }
          selectRegionProps(props, { panTo:true, lat, lng, zoom:8 });
          setGeoStatus('Could not find ZIP, but selected ecoregion by coordinates.');
        }
      },
      (err) => setGeoStatus(`Location error: ${err.message}`),
      { enableHighAccuracy:true, timeout:10000, maximumAge:60000 }
    );
  }

  // Filters UI (separate controls per category)
  const filtersGrid = document.getElementById('filtersGrid');
  const filterControls = new Map();
  let advancedVisible = false;

  function setAdvancedVisible(visible){
    advancedVisible = visible;
    for (const ctrl of filterControls.values()) {
      if (!ctrl.advanced) continue;
      ctrl.wrapper.classList.toggle('hidden', !advancedVisible);
    }
    document.getElementById('toggleAdvancedBtn').textContent = advancedVisible ? 'Hide advanced' : 'Show advanced';
  }

  function clearAllFilters(){
    if (regionFilterControl) regionFilterControl.el.value = '';
    for (const ctrl of filterControls.values()) ctrl.el.value = '';
  }

  document.getElementById('clearFiltersBtn').addEventListener('click', ()=>{
    clearAllFilters();
    selectRegionProps(null);
    setGeoStatus('Filters cleared.');
  });

  document.getElementById('toggleAdvancedBtn').addEventListener('click', ()=>{
    setAdvancedVisible(!advancedVisible);
  });

  function isAdvancedColumnBestGuess(col, uniqueEstimate){
    if (uniqueEstimate > 60) return true;
    const n = normalizeKey(col);
    if (n.includes('where') || n.includes('period')) return true;
    return false;
  }
  function decideKind(uniqueEstimate){
    if (uniqueEstimate > 120) return 'text';
    return 'dropdown';
  }

  function setSelectOptions(selectEl, values){
    const current = String(selectEl.value ?? '');
    selectEl.innerHTML = '';

    const anyOpt = document.createElement('option');
    anyOpt.value = '';
    anyOpt.textContent = 'Any';
    selectEl.appendChild(anyOpt);

    for (const v of values) {
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = v;
      selectEl.appendChild(opt);
    }

    const has = [...selectEl.options].some(o => o.value === current);
    selectEl.value = has ? current : '';
  }

  function uniqueValuesFromList(list, col){
    const set = new Set();
    for (const p of list) {
      const cell = String(p.raw?.[col] ?? '').trim();
      if (!cell) continue;
      tokenizeCell(cell).forEach(t => set.add(t));
    }
    return set;
  }

  function rebuildDropdownOptionsFromList(list){
    for (const [col, ctrl] of filterControls.entries()) {
      if (ctrl.kind !== 'dropdown') continue;
      const valuesSet = uniqueValuesFromList(list, col);
      if (ctrl.isBoolean) {
        setSelectOptions(ctrl.el, canonicalYesNoOptions(valuesSet));
      } else {
        const vals = [...valuesSet].filter(v => String(v).trim() !== '').sort((a,b)=>String(a).localeCompare(String(b)));
        setSelectOptions(ctrl.el, vals);
      }
    }
  }

  function getActiveFilters(){
    const active = [];
    for (const [col, ctrl] of filterControls.entries()) {
      const v = String(ctrl.el.value ?? '').trim();
      if (!v) continue;
      active.push({ col, kind: ctrl.kind, value: v });
    }
    return active;
  }

  function buildRegionDropdown(){
    const wrapper = document.createElement('div');
    wrapper.className = 'filterBox';

    const label = document.createElement('div');
    label.className = 'filterLabel';
    label.textContent = 'Region';
    wrapper.appendChild(label);

    const sel = document.createElement('select');
    sel.innerHTML = `<option value="">All regions</option>`;
    wrapper.appendChild(sel);

    const hint = document.createElement('div');
    hint.className = 'filterHint';
    hint.textContent = 'Pick a region (optional). You can also click the map, use ZIP, or use Lat/Lng.';
    wrapper.appendChild(hint);

    sel.addEventListener('change', ()=>{
      const rawKey = String(sel.value || '').trim();
      if (!rawKey) {
        selectRegionProps(null);
        setGeoStatus('Region cleared (showing all regions).');
      } else {
        const props = regionKeyToProps.get(rawKey) || null;
        selectRegionProps(props);
        setGeoStatus('Region selected from dropdown.');
      }
    });

    filtersGrid.appendChild(wrapper);
    regionFilterControl = { el: sel, wrapper, kind:'region' };

    if (regionIndex.length) {
      const current = String(sel.value || '');
      sel.innerHTML = `<option value="">All regions</option>`;
      for (const r of regionIndex) {
        const opt = document.createElement('option');
        opt.value = r.rawKey;
        opt.textContent = r.label;
        sel.appendChild(opt);
      }
      sel.value = current;
    }
  }

  function buildFilterControls(globalStats){
    filtersGrid.innerHTML = '';
    filterControls.clear();

    buildRegionDropdown();

    const excluded = new Set([colL3Key, colCommon, colScientific, ...EXCLUDED_COLUMNS]);
    const cols = csvHeaders.filter(c => c && c.trim() && !excluded.has(c));

    const preferred = [
      'Plant Type','ROOT_TYPE','ROOT_DEPTH',
      'PLANT_GROWTH_TIME','PLANTING_SEASON','SUN_EXPOSURE','WATER_NEEDS',
      'Height (feet)','Lifespan','Soil Moisture','pH (Range)','Active Growth Period',
      'Drought Tolerance','Fire Tolerance','Pollinators',
      'GRAVEL_SOIL','SAND_SOIL','LOAM_SOIL','CHALKY_SOIL','SILT_SOIL','CLAY_SOIL','PEAT_SOIL',
      'INVASIVE','INVASIVE_WHERE'
    ];

    const ordered = [];
    for (const p of preferred) {
      const found = cols.find(c => normalizeKey(c) === normalizeKey(p));
      if (found && !ordered.includes(found)) ordered.push(found);
    }
    for (const c of cols.sort((a,b)=>a.localeCompare(b))) if (!ordered.includes(c)) ordered.push(c);

    for (const col of ordered) {
      const stats = globalStats[col] || { uniqueEstimate: 0, sampleUniques: new Set() };
      const kind = decideKind(stats.uniqueEstimate);

      const sampleVals = [...stats.sampleUniques].filter(v => String(v).trim() !== '');
      const isBoolean = sampleVals.length > 0 && sampleVals.length <= 12 && sampleVals.every(isYesNoLike);

      const advanced = isAdvancedColumnBestGuess(col, stats.uniqueEstimate);

      const wrapper = document.createElement('div');
      wrapper.className = 'filterBox' + (advanced && !advancedVisible ? ' hidden' : '');

      const label = document.createElement('div');
      label.className = 'filterLabel';
      label.textContent = col + (advanced ? ' (advanced)' : '');
      wrapper.appendChild(label);

      if (kind === 'dropdown') {
        const sel = document.createElement('select');
        sel.innerHTML = `<option value="">Any</option>`;
        sel.addEventListener('change', ()=>{ currentPage = 1; renderResults(); });
        wrapper.appendChild(sel);

        const hint = document.createElement('div');
        hint.className = 'filterHint';
        hint.textContent = isBoolean ? 'Dropdown (Yes/No + UNCERTAIN if present)' : 'Dropdown (values pulled from spreadsheet)';
        wrapper.appendChild(hint);

        filtersGrid.appendChild(wrapper);
        filterControls.set(col, { el: sel, wrapper, advanced, kind:'dropdown', isBoolean });

      } else {
        const inp = document.createElement('input');
        inp.placeholder = 'type to match (contains)‚Ä¶';
        inp.addEventListener('input', ()=>{ currentPage = 1; renderResults(); });
        wrapper.appendChild(inp);

        const hint = document.createElement('div');
        hint.className = 'filterHint';
        hint.textContent = 'Text filter (contains) ‚Äî used when there are too many dropdown values';
        wrapper.appendChild(hint);

        filtersGrid.appendChild(wrapper);
        filterControls.set(col, { el: inp, wrapper, advanced, kind:'text', isBoolean:false });
      }
    }

    setAdvancedVisible(false);
  }

  // Results + pagination
  const elResults = document.getElementById('results');
  const elCount = document.getElementById('resultCount');
  const elPageMeta = document.getElementById('pageMeta');
  const elActiveFiltersLine = document.getElementById('activeFiltersLine');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');

  prevBtn.addEventListener('click', ()=>{ currentPage = Math.max(1, currentPage - 1); renderResults(); });
  nextBtn.addEventListener('click', ()=>{ currentPage = currentPage + 1; renderResults(); });

  function getFilteredPlants(){
    const base = getPlantsForRegionProps(selectedProps);
    const q = normText(document.getElementById('searchBox').value);
    const activeFilters = getActiveFilters();

    return base.filter(p => {
      if (q) {
        const ok = normText(p.commonName).includes(q) || normText(p.scientificName).includes(q);
        if (!ok) return false;
      }
      for (const f of activeFilters) {
        const cell = p.raw?.[f.col];
        if (f.kind === 'dropdown') {
          if (!matchesDropdownCell(cell, f.value)) return false;
        } else {
          const cellStr = String(cell ?? '').trim();
          if (!cellStr) return false;
          if (!normText(cellStr).includes(normText(f.value))) return false;
        }
      }
      return true;
    });
  }

  function renderResults(){
    elResults.innerHTML = '';
    elCount.textContent = '';
    elPageMeta.textContent = '';
    elActiveFiltersLine.textContent = '';

    const filtered = getFilteredPlants();
    const activeFilters = getActiveFilters();

    if (activeFilters.length) {
      elActiveFiltersLine.innerHTML =
        `<b>Active filters:</b> ` +
        activeFilters.map(f => `${escapeHtml(f.col)} = <code>${escapeHtml(f.value)}</code>`).join(' &nbsp; ');
    }

    const total = filtered.length;
    const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
    currentPage = Math.min(Math.max(1, currentPage), totalPages);

    const startIdx = (currentPage - 1) * PAGE_SIZE;
    const endIdx = Math.min(startIdx + PAGE_SIZE, total);
    const pageItems = filtered.slice(startIdx, endIdx);

    elCount.textContent = `(${total} matches)`;
    elPageMeta.textContent = total
      ? `Page ${currentPage} of ${totalPages} ‚Ä¢ Showing ${startIdx + 1}-${endIdx}`
      : `Page 1 of 1 ‚Ä¢ Showing 0`;

    prevBtn.disabled = currentPage <= 1;
    nextBtn.disabled = currentPage >= totalPages;

    if (!pageItems.length) {
      elResults.innerHTML = '<div class="small">No plants match those filters.</div>';
      return;
    }

    const summaryFieldsWanted = ['Plant Type','ROOT_TYPE','ROOT_DEPTH'];
    const summaryFields = [];
    for (const w of summaryFieldsWanted) {
      const found = csvHeaders.find(h => normalizeKey(h) === normalizeKey(w));
      if (found && !summaryFields.includes(found)) summaryFields.push(found);
    }

    pageItems.forEach((p, idx)=>{
      const cardId = `${startIdx + idx}`;
      const card = document.createElement('div');
      card.className = 'plant';
      card.id = `plant-${cardId}`;

      const lines = [];
      for (const c of summaryFields) {
        const v = String(p.raw?.[c] ?? '').trim();
        if (v) lines.push(`<div><span class="key">${escapeHtml(c)}:</span> ${escapeHtml(v)}</div>`);
      }

      card.innerHTML = `
        <b>${escapeHtml(p.commonName || '(no common name)')}</b>
        <div class="small"><i>${escapeHtml(p.scientificName || '(no scientific name)')}</i></div>
        <div class="kv">${lines.join('')}</div>
      `;

      const moreRow = document.createElement('div');
      moreRow.className = 'moreRow';

      const btn = document.createElement('button');
      btn.className = 'secondary smallBtn';
      btn.type = 'button';
      btn.textContent = 'More info';

      const details = document.createElement('div');
      details.className = 'detailsBox hidden';
      details.id = `details-${cardId}`;

      const header = document.createElement('div');
      header.className = 'detailsBoxSummary';
      header.textContent = 'Plant details';
      details.appendChild(header);

      const grid = document.createElement('div');
      grid.className = 'detailsGrid';

      for (const col of detailColumns) {
        const val = String(p.raw?.[col] ?? '').trim();
        if (!val) continue;

        const line = document.createElement('div');
        line.className = 'detailLine';

        const k = document.createElement('div');
        k.className = 'detailKey';
        k.textContent = col;

        const v = document.createElement('div');
        v.className = 'detailVal';
        v.textContent = val;

        line.appendChild(k);
        line.appendChild(v);
        grid.appendChild(line);
      }

      if (!grid.children.length) {
        const empty = document.createElement('div');
        empty.className = 'small';
        empty.textContent = '(No additional details for this plant.)';
        details.appendChild(empty);
      } else {
        details.appendChild(grid);
      }

      btn.addEventListener('click', ()=>{
        const isHidden = details.classList.contains('hidden');
        details.classList.toggle('hidden', !isHidden);
        btn.textContent = isHidden ? 'Hide info' : 'More info';
      });

      moreRow.appendChild(btn);
      card.appendChild(moreRow);
      card.appendChild(details);

      elResults.appendChild(card);
    });
  }

  document.getElementById('searchBox').addEventListener('input', ()=>{ currentPage = 1; renderResults(); });

  // Quick plant lookup
  const quickInput = document.getElementById('plantLookup');
  const quickList = document.getElementById('quickList');

  function renderQuickList(matches){
    quickList.innerHTML = '';
    if (!matches.length) {
      quickList.innerHTML = `<div class="small">No matches.</div>`;
      return;
    }
    for (const m of matches.slice(0, 6)) {
      const div = document.createElement('div');
      div.className = 'quickItem';
      div.innerHTML = `<b>${escapeHtml(m.commonName || '(no common name)')}</b><div class="small"><i>${escapeHtml(m.scientificName || '')}</i></div>`;
      div.addEventListener('click', ()=>{
        const q = (m.commonName || m.scientificName || '').trim();
        document.getElementById('searchBox').value = q;
        currentPage = 1;
        renderResults();
        document.getElementById('results').scrollIntoView({ behavior:'smooth', block:'start' });
      });
      quickList.appendChild(div);
    }
  }

  quickInput.addEventListener('input', ()=>{
    const q = normText(quickInput.value);
    if (!q) { quickList.innerHTML = ''; return; }
    const matches = plants.filter(p =>
      normText(p.commonName).includes(q) || normText(p.scientificName).includes(q)
    );
    renderQuickList(matches);
  });

  // Load CSV
  function pickFirstExistingHeader(candidates, headers, fallback){
    for (const c of candidates) {
      const found = headers.find(h => normalizeKey(h) === normalizeKey(c));
      if (found) return found;
    }
    return fallback;
  }

  async function loadPlantDatabaseCSV(){
    setStatus('Loading plant database CSV‚Ä¶');
    logDebug('‚û°Ô∏è fetch CSV', DATABASE_CSV_URL);

    const res = await fetch(DATABASE_CSV_URL, { cache:'no-store' });
    logDebug('‚¨ÖÔ∏è CSV status', res.status);
    if (!res.ok) throw new Error(`Failed to load CSV: ${res.status}`);

    const text = await res.text();
    const parsed = parseCSV(text);
    const rows = parsed.rows || [];
    if (!rows.length) throw new Error('CSV loaded but has 0 rows.');

    csvHeaders = parsed.headers || Object.keys(rows[0] || {});
    colL3Key = pickFirstExistingHeader(L3_KEY_CANDIDATES, csvHeaders, 'L3_KEY');
    colCommon = pickFirstExistingHeader(COMMON_CANDIDATES, csvHeaders, 'Common Name');
    colScientific = pickFirstExistingHeader(SCI_CANDIDATES, csvHeaders, 'Scientific Name');

    logDebug('‚úÖ Column mapping', { colL3Key, colCommon, colScientific });

    const globalStats = {};
    for (const col of csvHeaders) {
      const set = new Set();
      const sampleLimit = Math.min(rows.length, 6000);
      for (let i=0;i<sampleLimit;i++){
        const v = String(rows[i]?.[col] ?? '').trim();
        if (!v) continue;
        set.add(v);
        if (set.size > 220) break;
      }
      globalStats[col] = { uniqueEstimate: set.size, sampleUniques: set };
    }

    plants = rows.map(r => {
      const l3Raw = String(r[colL3Key] ?? '').trim();
      return {
        l3Raw,
        l3Norm: normalizeKey(l3Raw),
        l3Code: extractLeadingCode(l3Raw),
        commonName: String(r[colCommon] ?? '').trim(),
        scientificName: String(r[colScientific] ?? '').trim(),
        raw: r
      };
    });

    indexPlants();

    detailColumns = csvHeaders
      .filter(c => c && c.trim())
      .filter(c => !EXCLUDED_COLUMNS.has(c))
      .filter(c => normalizeKey(c) !== normalizeKey(colL3Key))
      .sort((a,b)=>a.localeCompare(b));

    document.getElementById('colInfo').innerHTML = `
      <div class="small">
        Loaded <b>${rows.length.toLocaleString()}</b> rows and <b>${csvHeaders.length}</b> columns.
        Showing ${PAGE_SIZE} plants per page. Vendor/link columns removed.
      </div>
    `;

    buildFilterControls(globalStats);
    rebuildDropdownOptionsFromList(plants);

    selectRegionProps(null);
    setStatus('CSV loaded. Filters + plants should now be visible.');
    refreshAllTooltips();
  }

  // Load GeoJSON map
  async function loadEcoregionsGeoJSON(){
    setStatus('Loading ecoregion map‚Ä¶');
    logDebug('‚û°Ô∏è fetch GeoJSON', ECOREGIONS_URL);

    const res = await fetch(ECOREGIONS_URL, { cache:'no-store' });
    logDebug('‚¨ÖÔ∏è GeoJSON status', res.status);
    if (!res.ok) throw new Error(`Failed to load map JSON: ${res.status}`);

    const geojson = await res.json();
    ecoregionGeoJSON = geojson;
    logDebug('‚úÖ GeoJSON parsed', { type: geojson.type, features: geojson.features?.length });

    regionIndex = [];
    regionKeyToProps = new Map();
    for (const f of (geojson.features || [])) {
      const p = f.properties || {};
      const rawKey = String(p.L3_KEY ?? '').trim();
      if (!rawKey) continue;
      const code = String(p.US_L3CODE ?? '').trim() || extractLeadingCode(rawKey);
      const name = p.US_L3NAME || p.NA_L3NAME || '';
      const label = `${code || rawKey}${name ? ' ‚Äî ' + name : ''}`;
      regionIndex.push({ label, rawKey, code, name });
      regionKeyToProps.set(rawKey, p);
    }
    regionIndex.sort((a,b)=>a.label.localeCompare(b.label));

    if (ecoregionsLayer) { try { map.removeLayer(ecoregionsLayer); } catch {} }

    function onEachFeature(feature, layer){
      const p = feature.properties || {};
      layer.bindTooltip(buildTooltipHtml(p), { sticky:true, direction:'auto', opacity:0.95 });

      layer.on('mouseover', ()=>{
        const tt = layer.getTooltip ? layer.getTooltip() : null;
        if (tt && tt.setContent) tt.setContent(buildTooltipHtml(p));
        layer.setStyle({ weight:2, opacity:1, fillOpacity:0.30 });
      });

      layer.on('mouseout', ()=>{
        if (!selectedProps) layer.setStyle(styleForFeature());
        else {
          const key = String(p.L3_KEY ?? '').trim();
          const selKey = String(selectedProps.L3_KEY ?? '').trim();
          if (key && selKey && key === selKey) layer.setStyle(styleForSelected());
          else layer.setStyle(styleForDimmed());
        }
      });

      layer.on('click', ()=>{
        selectRegionProps(p);
        const rawKey = String(p.L3_KEY ?? '').trim();
        if (regionFilterControl) regionFilterControl.el.value = rawKey;

        const regionPlants = getPlantsForRegionProps(selectedProps);
        rebuildDropdownOptionsFromList(regionPlants);

        setGeoStatus('Region selected from map.');
      });
    }

    ecoregionsLayer = L.geoJSON(geojson, { style: styleForFeature, onEachFeature }).addTo(map);

    try {
      const b = ecoregionsLayer.getBounds();
      if (b.isValid()) map.fitBounds(b, { padding:[10,10] });
    } catch {}

    if (regionFilterControl) {
      const sel = regionFilterControl.el;
      const current = String(sel.value || '');
      sel.innerHTML = `<option value="">All regions</option>`;
      for (const r of regionIndex) {
        const opt = document.createElement('option');
        opt.value = r.rawKey;
        opt.textContent = r.label;
        sel.appendChild(opt);
      }
      sel.value = current;
    }

    setStatus('Map loaded.');
  }

  // Debug UI wiring + buttons
  window.addEventListener('DOMContentLoaded', ()=>{
    document.getElementById('debugFab').addEventListener('click', openDebug);
    document.getElementById('debugModalBackdrop').addEventListener('click', closeDebug);
    document.getElementById('debugCloseBtn').addEventListener('click', closeDebug);
    document.getElementById('debugClearBtn').addEventListener('click', ()=>{ debugLines=[]; logDebug('üßπ Log cleared'); });
    document.getElementById('debugCopyBtn').addEventListener('click', async ()=>{
      try { await navigator.clipboard.writeText(debugLines.join('\n')); logDebug('‚úÖ Copied log'); }
      catch(err){ logDebug('‚ùå Copy failed', String(err)); alert('Copy blocked. Select text and copy manually.'); }
    });

    document.getElementById('zipFindBtn').addEventListener('click', ()=>findByZip(document.getElementById('zipInput').value));
    document.getElementById('zipInput').addEventListener('keydown', (e)=>{ if (e.key === 'Enter') findByZip(document.getElementById('zipInput').value); });
    document.getElementById('zipLocBtn').addEventListener('click', useMyLocationZip);

    document.getElementById('latlngFindBtn').addEventListener('click', findByLatLngInputs);
    document.getElementById('latInput').addEventListener('keydown', (e)=>{ if (e.key === 'Enter') findByLatLngInputs(); });
    document.getElementById('lngInput').addEventListener('keydown', (e)=>{ if (e.key === 'Enter') findByLatLngInputs(); });
    document.getElementById('latlngLocBtn').addEventListener('click', useMyLocationLatLng);

    logDebug('‚úÖ Debug UI ready');
  });

  // Boot
  (async function start(){
    try {
      logDebug('üöÄ App starting', { ECOREGIONS_URL, DATABASE_CSV_URL });
      await loadEcoregionsGeoJSON();
      await loadPlantDatabaseCSV();
      refreshAllTooltips();
      setGeoStatus('Ready: search plants, use filters, or find ecoregion by ZIP or Lat/Lng.');
      logDebug('‚úÖ App ready');
    } catch (err) {
      logDebug('‚ùå App start error', String(err));
      setStatus('ERROR: ' + err.message);
      openDebug();
    }
  })();
</script>
</body>
</html>
